--- openssl/digest.cpp
+++ openssl/digest.cpp
@@ -18,6 +18,21 @@
 
 #include "local.h"
 
+#ifdef HAVE_OPENSSL_OPENSSLV_H
+#include <openssl/opensslv.h>
+#endif
+
+#ifdef HAVE_OPENSSL_CRYPTO_H
+#include <openssl/crypto.h>
+#endif
+
+#ifdef HAVE_OPENSSL_EVP_H
+#include <openssl/evp.h>
+#endif
+
+#include <stdexcept>
+#include <cassert>
+
 namespace ucommon {
 
 bool Digest::has(const char *id)
@@ -36,26 +51,49 @@
         type = "sha1";
 
     hashtype = (void *)EVP_get_digestbyname(type);
-    if(hashtype) {
+    assert(hashtype != NULL);
+
+    if (hashtype)
+    {
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+        context = EVP_MD_CTX_new();
+        assert(context != NULL);
+
+        if (context) {
+            int rc = EVP_DigestInit_ex((EVP_MD_CTX*)context, (const EVP_MD*)hashtype, NULL);
+            if (rc != 1) throw std::runtime_error("EVP_DigestInit_ex failed");
+        }
+#else
         context = new EVP_MD_CTX;
-        EVP_MD_CTX_init((EVP_MD_CTX *)context);
-        EVP_DigestInit_ex((EVP_MD_CTX *)context, (const EVP_MD *)hashtype, NULL);
+        assert(context != NULL);
+
+        if (context) {
+            EVP_MD_CTX_init((EVP_MD_CTX *)context);
+            EVP_DigestInit_ex((EVP_MD_CTX *)context, (const EVP_MD *)hashtype, NULL);
+        }
+#endif
     }
 }
 
 void Digest::release(void)
 {
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+    if(context)
+        EVP_MD_CTX_free((EVP_MD_CTX *)context);
+    context = NULL;
+#else
     if(context)
         EVP_MD_CTX_cleanup((EVP_MD_CTX *)context);
 
     if(context) {
-        memset(context, 0, sizeof(EVP_MD_CTX));
+        OPENSSL_cleanse(context, sizeof(EVP_MD_CTX));
         delete (EVP_MD_CTX *)context;
         context = NULL;
     }
+#endif
 
     bufsize = 0;
-    memset(textbuf, 0, sizeof(textbuf));
+    OPENSSL_cleanse(textbuf, sizeof(textbuf));
 }
 
 bool Digest::put(const void *address, size_t size)
@@ -63,23 +101,48 @@
     if(!context)
         return false;
 
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+    int rc = EVP_DigestUpdate((EVP_MD_CTX *)context, address, size);
+    return rc == 1;
+#else
     EVP_DigestUpdate((EVP_MD_CTX *)context, address, size);
     return true;
+#endif
 }
 
 void Digest::reset(void)
 {
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+    if(!context) {
+        if(hashtype) {
+            context = EVP_MD_CTX_new();
+            assert(context != NULL);
+        }
+        else
+            return;
+    }
+
+    if (context) {
+        int rc = EVP_DigestInit_ex((EVP_MD_CTX*)context, (const EVP_MD*)hashtype, NULL);
+        if (rc != 1) throw std::runtime_error("EVP_DigestInit_ex failed");
+        bufsize = 0;
+    }
+#else
     if(!context) {
         if(hashtype) {
             context = new EVP_MD_CTX;
+            assert(context != NULL);
             EVP_MD_CTX_init((EVP_MD_CTX *)context);
         }
         else
             return;
     }
 
-    EVP_DigestInit_ex((EVP_MD_CTX *)context, (const EVP_MD *)hashtype, NULL);
-    bufsize = 0;
+    if (context) {
+        EVP_DigestInit_ex((EVP_MD_CTX *)context, (const EVP_MD *)hashtype, NULL);
+        bufsize = 0;
+    }
+#endif
 }
 
 void Digest::recycle(bool bin)
@@ -89,6 +152,31 @@
     if(!context)
         return;
 
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+    int rc;
+    if(!bufsize) {
+        rc = EVP_DigestFinal_ex((EVP_MD_CTX *)context, buffer, &size);
+        if (rc != 1) throw std::runtime_error("EVP_DigestFinal_ex failed");
+    }
+
+    rc = EVP_DigestInit_ex((EVP_MD_CTX *)context, (const EVP_MD *)hashtype, NULL);
+    if (rc != 1) throw std::runtime_error("EVP_DigestInit_ex failed");
+
+    if(bin) {
+        rc = EVP_DigestUpdate((EVP_MD_CTX *)context, buffer, size);
+        if (rc != 1) throw std::runtime_error("EVP_DigestUpdate failed");
+    }
+    else {
+        unsigned count = 0;
+        while(count < size) {
+            snprintf(textbuf + (count * 2), 3, "%2.2x", buffer[count]);
+            ++count;
+        }
+        rc = EVP_DigestUpdate((EVP_MD_CTX *)context, textbuf, size * 2);
+        if (rc != 1) throw std::runtime_error("EVP_DigestUpdate failed");
+    }
+    bufsize = 0;
+#else
     if(!bufsize)
         EVP_DigestFinal_ex((EVP_MD_CTX *)context, buffer, &size);
 
@@ -99,15 +187,13 @@
     else {
         unsigned count = 0;
         while(count < size) {
-            snprintf(textbuf + (count * 2), 3, "%2.2x",
-buffer[count]);
+            snprintf(textbuf + (count * 2), 3, "%2.2x", buffer[count]);
             ++count;
         }
-        EVP_DigestUpdate((EVP_MD_CTX *)context, textbuf, size *
-2);
+        EVP_DigestUpdate((EVP_MD_CTX *)context, textbuf, size * 2);
     }
     bufsize = 0;
-
+#endif
 }
 
 const uint8_t *Digest::get(void)
@@ -121,7 +207,12 @@
     if(!context)
         return NULL;
 
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+    int rc = EVP_DigestFinal_ex((EVP_MD_CTX *)context, buffer, &size);
+    if (rc != 1) throw std::runtime_error("EVP_DigestFinal_ex failed");
+#else
     EVP_DigestFinal_ex((EVP_MD_CTX *)context, buffer, &size);
+#endif
 
     release();
 
--- openssl/random.cpp
+++ openssl/random.cpp
@@ -18,6 +18,14 @@
 
 #include "local.h"
 
+#ifdef HAVE_OPENSSL_OPENSSLV_H
+#include <openssl/opensslv.h>
+#endif
+
+#ifdef HAVE_OPENSSL_RAND_H
+#include <openssl/rand.h>
+#endif
+
 namespace ucommon {
 
 void Random::seed(void)
@@ -47,9 +55,15 @@
 {
     secure::init();
 
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+    if(RAND_bytes(buf, (int)size))
+        return size;
+    return 0;
+#else
     if(RAND_pseudo_bytes(buf, (int)size))
         return size;
     return 0;
+#endif
 }
 
 bool Random::status(void)
--- openssl/cipher.cpp
+++ openssl/cipher.cpp
@@ -18,6 +18,17 @@
 
 #include "local.h"
 
+#ifdef HAVE_OPENSSL_OPENSSLV_H
+#include <openssl/opensslv.h>
+#endif
+
+#ifdef HAVE_OPENSSL_EVP_H
+#include <openssl/evp.h>
+#endif
+
+#include <stdexcept>
+#include <cassert>
+
 static const uint8_t *_salt = NULL;
 static unsigned _rounds = 1;
 
@@ -76,6 +87,7 @@
         String::set(fpart, sizeof(algoname), fpart + 1);
 
     algotype = EVP_get_cipherbyname(algoname);
+    assert(algotype != NULL);
 
     if(!algotype)
         return;
@@ -96,7 +108,10 @@
     if(fpart && fpart == lpart)
         String::set(fpart, sizeof(algoname), fpart + 1);
 
-    return (EVP_get_cipherbyname(algoname) != NULL);
+    const EVP_CIPHER * cipher = EVP_get_cipherbyname(algoname);
+    assert(cipher != NULL);
+
+    return (cipher != NULL);
 }
 
 void Cipher::push(uint8_t *address, size_t size)
@@ -105,12 +120,19 @@
 
 void Cipher::release(void)
 {
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+    keys.clear();
+    if(context)
+        EVP_CIPHER_CTX_free((EVP_CIPHER_CTX*)context);
+    context = NULL;
+#else
     keys.clear();
     if(context) {
         EVP_CIPHER_CTX_cleanup((EVP_CIPHER_CTX*)context);
         delete (EVP_CIPHER_CTX*)context;
         context = NULL;
     }
+#endif
 }
 
 void Cipher::set(const key_t key, mode_t mode, uint8_t *address, size_t size)
@@ -125,10 +147,23 @@
     if(!keys.keysize)
         return;
 
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+    context = EVP_CIPHER_CTX_new();
+    assert(context != NULL);
+
+    if (context)
+    {
+        int rc = EVP_CipherInit_ex((EVP_CIPHER_CTX *)context, (EVP_CIPHER *)keys.algotype, NULL, keys.keybuf, keys.ivbuf, (int)mode);
+        if (rc != 1) throw std::runtime_error("EVP_CipherInit_ex failed");
+        rc = EVP_CIPHER_CTX_set_padding((EVP_CIPHER_CTX *)context, 0);
+        if (rc != 1) throw std::runtime_error("EVP_CIPHER_CTX_set_padding failed");
+    }
+#else
     context = new EVP_CIPHER_CTX;
     EVP_CIPHER_CTX_init((EVP_CIPHER_CTX *)context);
     EVP_CipherInit_ex((EVP_CIPHER_CTX *)context, (EVP_CIPHER *)keys.algotype, NULL, keys.keybuf, keys.ivbuf, (int)mode);
     EVP_CIPHER_CTX_set_padding((EVP_CIPHER_CTX *)context, 0);
+#endif
 }
 
 size_t Cipher::put(const uint8_t *data, size_t size)
--- openssl/hmac.cpp
+++ openssl/hmac.cpp
@@ -18,75 +18,128 @@
 
 #include "local.h"
 
+#ifdef HAVE_OPENSSL_OPENSSLV_H
+#include <openssl/opensslv.h>
+#endif
+
+#ifdef HAVE_OPENSSL_CRYPTO_H
+#include <openssl/crypto.h>
+#endif
+
+#ifdef HAVE_OPENSSL_EVP_H
+#include <openssl/evp.h>
+#endif
+
+#include <stdexcept>
+#include <cassert>
+
 namespace ucommon {
 
 bool HMAC::has(const char *id)
 {
-    return (EVP_get_digestbyname(id) != NULL);
+	return (EVP_get_digestbyname(id) != NULL);
 }
 
 void HMAC::set(const char *digest, const secure::keybytes& key)
 {
-    secure::init();
+	secure::init();
 
-    release();
+	release();
 
-    size_t len = key.size() / 8;
+	size_t len = key.size() / 8;
 
-    hmactype = EVP_get_digestbyname(digest);
-    if(hmactype && len) {
-        context = new ::HMAC_CTX;
-        HMAC_CTX_init((HMAC_CTX *)context);
-        HMAC_Init((HMAC_CTX *)context, *key, (int)len, (const EVP_MD *)hmactype);
-    }
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+	hmactype = EVP_get_digestbyname(digest);
+	assert(hmactype != NULL);
+
+	if(hmactype && len) {
+		context = HMAC_CTX_new();
+		assert(context != NULL);
+
+		if (context) {
+			int rc = HMAC_Init_ex((HMAC_CTX *)context, *key, (int)len, (const EVP_MD *)hmactype, NULL);
+			if (rc != 1) throw std::runtime_error("HMAC_Init_ex failed");
+		}
+	}
+#else
+	hmactype = EVP_get_digestbyname(digest);
+	assert(hmactype != NULL);
+
+	if(hmactype && len) {
+		context = new HMAC_CTX;
+		assert(context != NULL);
+
+		if (context) {
+			HMAC_CTX_init((HMAC_CTX *)context);
+			HMAC_Init((HMAC_CTX *)context, *key, (int)len, (const EVP_MD *)hmactype);
+		}
+	}
+#endif
 }
 
 void HMAC::release(void)
 {
-    if(context) {
-        HMAC_cleanup((HMAC_CTX *)context);
-        memset(context, 0, sizeof(HMAC_CTX));
-        delete (HMAC_CTX *)context;
-        context = NULL;
-    }
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+	if(context)
+		HMAC_CTX_free((HMAC_CTX *)context);
+	context = NULL;
+#else
+	if(context) {
+		HMAC_cleanup((HMAC_CTX *)context);
+		OPENSSL_cleanse(context, sizeof(HMAC_CTX));
+		delete (HMAC_CTX *)context;
+		context = NULL;
+	}
+#endif
 
-    bufsize = 0;
-    memset(textbuf, 0, sizeof(textbuf));
+	bufsize = 0;
+	OPENSSL_cleanse(textbuf, sizeof(textbuf));
 }
 
 bool HMAC::put(const void *address, size_t size)
 {
-    if(!context)
-        return false;
+	if(!context)
+		return false;
 
-    HMAC_Update((HMAC_CTX *)context, (const uint8_t *)address, size);
-    return true;
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+	int rc = HMAC_Update((HMAC_CTX *)context, (const uint8_t *)address, size);
+	return rc == 1;
+#else
+	HMAC_Update((HMAC_CTX *)context, (const uint8_t *)address, size);
+	return true;
+#endif
 }
 
 const uint8_t *HMAC::get(void)
 {
-    unsigned count = 0;
-    unsigned size = 0;
+	unsigned count = 0;
+	unsigned size = 0;
 
-    if(bufsize)
-        return buffer;
+	if(bufsize)
+		return buffer;
 
-    if(!context)
-        return NULL;
+	if(!context)
+		return NULL;
 
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+	int rc = HMAC_Final((HMAC_CTX *)context, buffer, &size);
+	if (rc != 1) throw std::runtime_error("HMAC_Final failed");
+#else
 	HMAC_Final((HMAC_CTX *)context, buffer, &size);
+#endif
+
 	release();
 
 	if(!size)
 		return NULL;
 
-    bufsize = size;
+	bufsize = size;
 
-    while(count < bufsize) {
-        snprintf(textbuf + (count * 2), 3, "%2.2x", buffer[count]);
-        ++count;
-    }
-    return buffer;
+	while(count < bufsize) {
+		snprintf(textbuf + (count * 2), 3, "%2.2x", buffer[count]);
+		++count;
+	}
+	return buffer;
 }
 
 } // namespace ucommon
--- commoncpp/tcp.cpp
+++ commoncpp/tcp.cpp
@@ -482,10 +482,13 @@
 TCPStream::~TCPStream()
 {
 #ifdef  CCXX_EXCEPTIONS
-        try { endStream(); }
-        catch( ... ) { if ( ! std::uncaught_exception()) throw;};
+    try { endStream(); }
+    catch( ... ) {  // ugh...
+        if (! std::uncaught_exception())
+            throw;  // rethrow
+    };
 #else
-        endStream();
+    endStream();
 #endif
 }
 
--- corelib/arrayref.cpp
+++ corelib/arrayref.cpp
@@ -212,7 +212,7 @@
 
 void ArrayRef::clear(void)
 {
-    reset(nullptr);
+    reset(UCOMMON_NULLPTR);
 }
 
 ArrayRef::Array *ArrayRef::create(arraytype_t mode, size_t size)
--- corelib/atomic.cpp
+++ corelib/atomic.cpp
@@ -468,7 +468,7 @@
             --base;
         }
         ::free(base);
-        address = nullptr;
+        address = UCOMMON_NULLPTR;
     }
 }
 
--- corelib/linked.cpp
+++ corelib/linked.cpp
@@ -22,11 +22,15 @@
 #include <ucommon/string.h>
 #include <ucommon/thread.h>
 
+#ifndef UCOMMON_NULLPTR
+# define UCOMMON_NULLPTR NULL
+#endif
+
 namespace ucommon {
 
 LinkedObject::LinkedObject(LinkedObject **root)
 {
-    assert(root != nullptr);
+    assert(root != UCOMMON_NULLPTR);
     enlist(root);
 }
 
@@ -38,7 +42,7 @@
 {
     LinkedObject *after;
 
-    assert(root != nullptr);
+    assert(root != UCOMMON_NULLPTR);
 
     while(root) {
         after = root->Next;
@@ -49,7 +53,7 @@
 
 bool LinkedObject::is_member(LinkedObject *list) const
 {
-    assert(list != nullptr);
+    assert(list != UCOMMON_NULLPTR);
 
     while(list) {
         if(list == this)
@@ -61,7 +65,7 @@
 
 void LinkedObject::enlist(LinkedObject **root)
 {
-    assert(root != nullptr);
+    assert(root != UCOMMON_NULLPTR);
 
     Next = *root;
     *root = this;
@@ -69,9 +73,9 @@
 
 void LinkedObject::delist(LinkedObject **root)
 {
-    assert(root != nullptr);
+    assert(root != UCOMMON_NULLPTR);
 
-    LinkedObject *prior = nullptr, *node = *root;
+    LinkedObject *prior = UCOMMON_NULLPTR, *node = *root;
 
     while(node && node != this) {
         prior = node;
@@ -89,22 +93,22 @@
 
 void ReusableObject::release(void)
 {
-    Next = nullptr;
+    Next = UCOMMON_NULLPTR;
 }
 
 NamedObject::NamedObject() :
 OrderedObject()
 {
-    Id = nullptr;
+    Id = UCOMMON_NULLPTR;
 }
 
 NamedObject::NamedObject(OrderedIndex *root, char *nid) :
 OrderedObject()
 {
-    assert(root != nullptr);
-    assert(nid != nullptr && *nid != 0);
+    assert(root != UCOMMON_NULLPTR);
+    assert(nid != UCOMMON_NULLPTR && *nid != 0);
 
-    NamedObject *node = static_cast<NamedObject*>(root->head), *prior = nullptr;
+    NamedObject *node = static_cast<NamedObject*>(root->head), *prior = UCOMMON_NULLPTR;
 
     while(node) {
         if(node->equal(nid)) {
@@ -118,7 +122,7 @@
         prior = node;
         node = node->getNext();
     }
-    Next = nullptr;
+    Next = UCOMMON_NULLPTR;
     Id = nid;
     if(!root->head)
         root->head = this;
@@ -135,23 +139,23 @@
 NamedObject::NamedObject(NamedObject **root, char *nid, unsigned max) :
 OrderedObject()
 {
-    assert(root != nullptr);
-    assert(nid != nullptr && *nid != 0);
+    assert(root != UCOMMON_NULLPTR);
+    assert(nid != UCOMMON_NULLPTR && *nid != 0);
     assert(max > 0);
 
-    Id = nullptr;
+    Id = UCOMMON_NULLPTR;
     add(root, nid, max);
 }
 
 void NamedObject::add(NamedObject **root, char *nid, unsigned max)
 {
-    assert(root != nullptr);
-    assert(nid != nullptr && *nid != 0);
+    assert(root != UCOMMON_NULLPTR);
+    assert(nid != UCOMMON_NULLPTR && *nid != 0);
     assert(max > 0);
 
     clearId();
 
-    NamedObject *node, *prior = nullptr;
+    NamedObject *node, *prior = UCOMMON_NULLPTR;
 
     if(max < 2)
         max = 0;
@@ -185,7 +189,7 @@
 {
     if(Id) {
         free(Id);
-        Id = nullptr;
+        Id = UCOMMON_NULLPTR;
     }
 }
 
@@ -217,7 +221,7 @@
 
 LinkedObject *LinkedObject::getIndexed(LinkedObject *root, unsigned index)
 {
-    while(index-- && root != nullptr)
+    while(index-- && root != UCOMMON_NULLPTR)
         root = root->Next;
 
     return root;
@@ -225,7 +229,7 @@
 
 unsigned LinkedObject::count(const LinkedObject *root)
 {
-    assert(root != nullptr);
+    assert(root != UCOMMON_NULLPTR);
 
     unsigned c = 0;
     while(root) {
@@ -237,7 +241,7 @@
 
 unsigned NamedObject::keyindex(const char *id, unsigned max)
 {
-    assert(id != nullptr && *id != 0);
+    assert(id != UCOMMON_NULLPTR && *id != 0);
     assert(max > 1);
 
     unsigned val = 0;
@@ -250,7 +254,7 @@
 
 int NamedObject::compare(const char *cid) const
 {
-    assert(cid != nullptr && *cid != 0);
+    assert(cid != UCOMMON_NULLPTR && *cid != 0);
 
 #ifdef  HAVE_STRCOLL
     return strcoll(Id, cid);
@@ -263,17 +267,17 @@
 
     static int ncompare(const void *o1, const void *o2)
     {
-        assert(o1 != nullptr);
-        assert(o2 != nullptr);
+        assert(o1 != UCOMMON_NULLPTR);
+        assert(o2 != UCOMMON_NULLPTR);
         const NamedObject * const *n1 = static_cast<const NamedObject * const*>(o1);
-        const NamedObject * const*n2 = static_cast<const NamedObject * const*>(o2);
+        const NamedObject * const *n2 = static_cast<const NamedObject * const*>(o2);
         return ((*n1)->compare((*n2)->getId()));
     }
 }
 
 NamedObject **NamedObject::sort(NamedObject **list, size_t size)
 {
-    assert(list != nullptr);
+    assert(list != UCOMMON_NULLPTR);
 
     if(!size) {
         while(list[size])
@@ -286,23 +290,23 @@
 
 NamedObject **NamedObject::index(NamedObject **idx, unsigned max)
 {
-    assert(idx != nullptr);
+    assert(idx != UCOMMON_NULLPTR);
     assert(max > 0);
     NamedObject **op = new NamedObject *[count(idx, max) + 1];
     unsigned pos = 0;
-    NamedObject *node = skip(idx, nullptr, max);
+    NamedObject *node = skip(idx, UCOMMON_NULLPTR, max);
 
     while(node) {
         op[pos++] = node;
         node = skip(idx, node, max);
     }
-    op[pos] = nullptr;
+    op[pos] = UCOMMON_NULLPTR;
     return op;
 }
 
 NamedObject *NamedObject::skip(NamedObject **idx, NamedObject *rec, unsigned max)
 {
-    assert(idx != nullptr);
+    assert(idx != UCOMMON_NULLPTR);
     assert(max > 0);
 
     unsigned key = 0;
@@ -313,7 +317,7 @@
         while(key < max && !idx[key])
             ++key;
         if(key >= max)
-            return nullptr;
+            return UCOMMON_NULLPTR;
         return idx[key];
     }
 
@@ -322,7 +326,7 @@
 
 void NamedObject::purge(NamedObject **idx, unsigned max)
 {
-    assert(idx != nullptr);
+    assert(idx != UCOMMON_NULLPTR);
     assert(max > 0);
 
     LinkedObject *root;
@@ -338,7 +342,7 @@
 
 unsigned NamedObject::count(NamedObject **idx, unsigned max)
 {
-    assert(idx != nullptr);
+    assert(idx != UCOMMON_NULLPTR);
     assert(max > 0);
 
     unsigned count = 0;
@@ -359,8 +363,8 @@
 
 NamedObject *NamedObject::remove(NamedObject **idx, const char *id, unsigned max)
 {
-    assert(idx != nullptr);
-    assert(id != nullptr && *id != 0);
+    assert(idx != UCOMMON_NULLPTR);
+    assert(id != UCOMMON_NULLPTR && *id != 0);
     assert(max > 0);
 
     if(max < 2)
@@ -371,8 +375,8 @@
 
 NamedObject *NamedObject::map(NamedObject **idx, const char *id, unsigned max)
 {
-    assert(idx != nullptr);
-    assert(id != nullptr && *id != 0);
+    assert(idx != UCOMMON_NULLPTR);
+    assert(id != UCOMMON_NULLPTR && *id != 0);
     assert(max > 0);
 
     if(max < 2)
@@ -383,7 +387,7 @@
 
 NamedObject *NamedObject::find(NamedObject *root, const char *id)
 {
-    assert(id != nullptr && *id != 0);
+    assert(id != UCOMMON_NULLPTR && *id != 0);
 
     while(root) {
         if(root->equal(id))
@@ -395,10 +399,10 @@
 
 NamedObject *NamedObject::remove(NamedObject **root, const char *id)
 {
-    assert(id != nullptr && *id != 0);
-    assert(root != nullptr);
+    assert(id != UCOMMON_NULLPTR && *id != 0);
+    assert(root != UCOMMON_NULLPTR);
 
-    NamedObject *prior = nullptr;
+    NamedObject *prior = UCOMMON_NULLPTR;
     NamedObject *node = *root;
 
     while(node) {
@@ -409,9 +413,9 @@
     }
 
     if(!node)
-        return nullptr;
+        return UCOMMON_NULLPTR;
 
-    if(prior == nullptr)
+    if(prior == UCOMMON_NULLPTR)
         *root = node->getNext();
     else
         prior->Next = node->getNext();
@@ -427,21 +431,21 @@
 NamedObject(), Child()
 {
     Id = nid;
-    Parent = nullptr;
+    Parent = UCOMMON_NULLPTR;
 }
 
 NamedTree::NamedTree(const NamedTree& source)
 {
     Id = source.Id;
-    Parent = nullptr;
+    Parent = UCOMMON_NULLPTR;
     Child = source.Child;
 }
 
 NamedTree::NamedTree(NamedTree *p, char *nid) :
 NamedObject(), Child()
 {
-    assert(p != nullptr);
-    assert(nid != nullptr && *nid != 0);
+    assert(p != UCOMMON_NULLPTR);
+    assert(nid != UCOMMON_NULLPTR && *nid != 0);
 
     enlistTail(&p->Child);
     Id = nid;
@@ -450,13 +454,13 @@
 
 NamedTree::~NamedTree()
 {
-    Id = nullptr;
+    Id = UCOMMON_NULLPTR;
     purge();
 }
 
 NamedTree *NamedTree::getChild(const char *tid) const
 {
-    assert(tid != nullptr && *tid != 0);
+    assert(tid != UCOMMON_NULLPTR && *tid != 0);
 
     linked_pointer<NamedTree> node = Child.begin();
 
@@ -465,7 +469,7 @@
             return *node;
         node.next();
     }
-    return nullptr;
+    return UCOMMON_NULLPTR;
 }
 
 void NamedTree::relistTail(NamedTree *trunk)
@@ -495,7 +499,7 @@
 
 NamedTree *NamedTree::path(const char *tid) const
 {
-    assert(tid != nullptr && *tid != 0);
+    assert(tid != UCOMMON_NULLPTR && *tid != 0);
 
     const char *np;
     char buf[65];
@@ -507,7 +511,7 @@
 
     while(*tid == '.') {
         if(!node->Parent)
-            return nullptr;
+            return UCOMMON_NULLPTR;
         node = node->Parent;
 
         ++tid;
@@ -522,7 +526,7 @@
         if(np)
             tid = ++np;
         else
-            tid = nullptr;
+            tid = UCOMMON_NULLPTR;
         node = node->getChild(buf);
     }
     return node;
@@ -530,7 +534,7 @@
 
 NamedTree *NamedTree::getLeaf(const char *tid) const
 {
-    assert(tid != nullptr && *tid != 0);
+    assert(tid != UCOMMON_NULLPTR && *tid != 0);
 
     linked_pointer<NamedTree> node = Child.begin();
 
@@ -539,12 +543,12 @@
             return *node;
         node.next();
     }
-    return nullptr;
+    return UCOMMON_NULLPTR;
 }
 
 NamedTree *NamedTree::leaf(const char *tid) const
 {
-    assert(tid != nullptr && *tid != 0);
+    assert(tid != UCOMMON_NULLPTR && *tid != 0);
 
     linked_pointer<NamedTree> node = Child.begin();
     NamedTree *obj;
@@ -552,19 +556,19 @@
     while(node) {
         if(node->is_leaf() && eq(node->Id, tid))
             return *node;
-        obj = nullptr;
+        obj = UCOMMON_NULLPTR;
         if(!node->is_leaf())
             obj = node->leaf(tid);
         if(obj)
             return obj;
         node.next();
     }
-    return nullptr;
+    return UCOMMON_NULLPTR;
 }
 
 NamedTree *NamedTree::find(const char *tid) const
 {
-    assert(tid != nullptr && *tid != 0);
+    assert(tid != UCOMMON_NULLPTR && *tid != 0);
 
     linked_pointer<NamedTree> node = Child.begin();
     NamedTree *obj;
@@ -579,12 +583,12 @@
         }
         node.next();
     }
-    return nullptr;
+    return UCOMMON_NULLPTR;
 }
 
 void NamedTree::setId(char *nid)
 {
-    assert(nid != nullptr && *nid != 0);
+    assert(nid != UCOMMON_NULLPTR && *nid != 0);
 
     Id = nid;
 }
@@ -597,7 +601,7 @@
     if(Parent)
         delist(&Parent->Child);
 
-    Id = nullptr;
+    Id = UCOMMON_NULLPTR;
 }
 
 void NamedTree::purge(void)
@@ -612,7 +616,7 @@
         obj = *node;
 		if (!obj)
 			break;
-        obj->Parent = nullptr; // save processing
+        obj->Parent = UCOMMON_NULLPTR; // save processing
         node = obj->getNext();
         delete obj;
     }
@@ -624,12 +628,12 @@
 
 LinkedObject::LinkedObject()
 {
-    Next = nullptr;
+    Next = UCOMMON_NULLPTR;
 }
 
 LinkedObject::LinkedObject(const LinkedObject& from)
 {
-    Next = nullptr;
+    Next = UCOMMON_NULLPTR;
 }
 
 OrderedObject::OrderedObject() : LinkedObject()
@@ -643,16 +647,16 @@
 OrderedObject::OrderedObject(OrderedIndex *root) :
 LinkedObject()
 {
-    assert(root != nullptr);
-    Next = nullptr;
+    assert(root != UCOMMON_NULLPTR);
+    Next = UCOMMON_NULLPTR;
     enlistTail(root);
 }
 
 void OrderedObject::delist(OrderedIndex *root)
 {
-    assert(root != nullptr);
+    assert(root != UCOMMON_NULLPTR);
 
-    OrderedObject *prior = nullptr, *node;
+    OrderedObject *prior = UCOMMON_NULLPTR, *node;
 
     node = root->head;
 
@@ -675,17 +679,17 @@
 
 void OrderedObject::enlist(OrderedIndex *root)
 {
-    assert(root != nullptr);
+    assert(root != UCOMMON_NULLPTR);
 
-    Next = nullptr;
+    Next = UCOMMON_NULLPTR;
     enlistTail(root);
 }
 
 void OrderedObject::enlistTail(OrderedIndex *root)
 {
-    assert(root != nullptr);
+    assert(root != UCOMMON_NULLPTR);
 
-    if(root->head == nullptr)
+    if(root->head == UCOMMON_NULLPTR)
         root->head = this;
     else if(root->tail)
         root->tail->Next = this;
@@ -695,10 +699,10 @@
 
 void OrderedObject::enlistHead(OrderedIndex *root)
 {
-    assert(root != nullptr);
+    assert(root != UCOMMON_NULLPTR);
 
-    Next = nullptr;
-    if(root->tail == nullptr)
+    Next = UCOMMON_NULLPTR;
+    if(root->tail == UCOMMON_NULLPTR)
         root->tail = this;
     else if(root->head)
         Next = root->head;
@@ -708,43 +712,43 @@
 
 DLinkedObject::DLinkedObject()
 {
-    Root = nullptr;
-    Prev = nullptr;
-    Next = nullptr;
+    Root = UCOMMON_NULLPTR;
+    Prev = UCOMMON_NULLPTR;
+    Next = UCOMMON_NULLPTR;
 }
 
 DLinkedObject::DLinkedObject(const DLinkedObject& from)
 {
-    Root = nullptr;
-    Prev = nullptr;
-    Next = nullptr;
+    Root = UCOMMON_NULLPTR;
+    Prev = UCOMMON_NULLPTR;
+    Next = UCOMMON_NULLPTR;
 }
 
 DLinkedObject::DLinkedObject(OrderedIndex *r)
 {
-    Root = nullptr;
-    Next = Prev = nullptr;
+    Root = UCOMMON_NULLPTR;
+    Next = Prev = UCOMMON_NULLPTR;
     if(r)
         enlist(r);
 }
 
 void DLinkedObject::enlist(OrderedIndex *r)
 {
-    assert(r != nullptr);
+    assert(r != UCOMMON_NULLPTR);
 
     enlistTail(r);
 }
 
 void DLinkedObject::insert(DLinkedObject *o)
 {
-    assert(o != nullptr);
+    assert(o != UCOMMON_NULLPTR);
 
     insertTail(o);
 }
 
 void DLinkedObject::insertHead(DLinkedObject *o)
 {
-    assert(o != nullptr);
+    assert(o != UCOMMON_NULLPTR);
 
     if(o->Root)
         o->delist();
@@ -755,7 +759,7 @@
     }
     else {
         Root->head = o;
-        o->Prev = nullptr;
+        o->Prev = UCOMMON_NULLPTR;
     }
     o->Root = Root;
     o->Next = this;
@@ -764,7 +768,7 @@
 
 void DLinkedObject::insertTail(DLinkedObject *o)
 {
-    assert(o != nullptr);
+    assert(o != UCOMMON_NULLPTR);
 
     if(o->Root)
         o->delist();
@@ -775,7 +779,7 @@
     }
     else {
         Root->tail = o;
-        o->Next = nullptr;
+        o->Next = UCOMMON_NULLPTR;
     }
     o->Root = Root;
     o->Prev = this;
@@ -784,14 +788,14 @@
 
 void DLinkedObject::enlistHead(OrderedIndex *r)
 {
-    assert(r != nullptr);
+    assert(r != UCOMMON_NULLPTR);
 
     if(Root)
         delist();
 
     Root = r;
-    Prev = nullptr; 
-    Next = nullptr;
+    Prev = UCOMMON_NULLPTR; 
+    Next = UCOMMON_NULLPTR;
 
     if(!Root->tail) {
         Root->tail = Root->head = static_cast<OrderedObject *>(this);
@@ -806,13 +810,13 @@
 
 void DLinkedObject::enlistTail(OrderedIndex *r)
 {
-    assert(r != nullptr);
+    assert(r != UCOMMON_NULLPTR);
 
     if(Root)
         delist();
 
     Root = r;
-    Next = Prev = nullptr;
+    Next = Prev = UCOMMON_NULLPTR;
 
     if(!Root->head) {
         Root->head = Root->tail = static_cast<OrderedObject *>(this);
@@ -839,8 +843,8 @@
     else if(Root->tail == static_cast<OrderedObject *>(this))
         Root->tail = static_cast<OrderedObject *>(Prev);
 
-    Root = nullptr;
-    Next = Prev = nullptr;
+    Root = UCOMMON_NULLPTR;
+    Next = Prev = UCOMMON_NULLPTR;
 }
 
 DLinkedObject::~DLinkedObject()
@@ -850,12 +854,12 @@
 
 OrderedIndex::OrderedIndex()
 {
-    head = tail = nullptr;
+    head = tail = UCOMMON_NULLPTR;
 }
 
 OrderedIndex::~OrderedIndex()
 {
-    head = tail = nullptr;
+    head = tail = UCOMMON_NULLPTR;
 }
 
 void OrderedIndex::copy(const OrderedIndex& source)
@@ -866,14 +870,14 @@
 
 void OrderedIndex::operator*=(OrderedObject *object)
 {
-    assert(object != nullptr);
+    assert(object != UCOMMON_NULLPTR);
 
     object->enlist(this);
 }
 
 void OrderedIndex::add(OrderedObject *object)
 {
-    assert(object != nullptr);
+    assert(object != UCOMMON_NULLPTR);
 
     object->enlist(this);
 }
@@ -883,12 +887,12 @@
     LinkedObject *node;
 
     if(!head)
-        return nullptr;
+        return UCOMMON_NULLPTR;
 
     node = head;
     head = static_cast<OrderedObject *>(node->getNext());
     if(!head)
-        tail = nullptr;
+        tail = UCOMMON_NULLPTR;
 
     return static_cast<LinkedObject *>(node);
 }
@@ -897,13 +901,13 @@
 {
     if(head) {
         LinkedObject::purge((LinkedObject *)head);
-        head = tail = nullptr;
+        head = tail = UCOMMON_NULLPTR;
     }
 }
 
 void OrderedIndex::reset(void)
 {
-    head = tail = nullptr;
+    head = tail = UCOMMON_NULLPTR;
 }
 
 void OrderedIndex::lock_index(void)
@@ -925,7 +929,7 @@
         op[idx++] = node;
         node = node->Next;
     }
-    op[idx] = nullptr;
+    op[idx] = UCOMMON_NULLPTR;
     return op;
 }
 
--- corelib/memory.cpp
+++ corelib/memory.cpp
@@ -42,6 +42,10 @@
 #define aligned_alloc(a, s) _aligned_malloc(s, a)
 #endif
 
+#ifndef UCOMMON_NULLPTR
+# define UCOMMON_NULLPTR NULL
+#endif
+
 namespace ucommon {
 
 extern "C" {
@@ -688,7 +692,7 @@
 {
     const char *out = NULL;
 
-    if(root == nullptr) {
+    if(root == UCOMMON_NULLPTR) {
         __THROW_RUNTIME("no root");
         return NULL;
     }
@@ -898,7 +902,7 @@
 }
 
 PagerObject::PagerObject() :
-LinkedObject(nullptr), CountedObject()
+LinkedObject(UCOMMON_NULLPTR), CountedObject()
 {
 }
 
--- corelib/shared.cpp
+++ corelib/shared.cpp
@@ -97,7 +97,7 @@
 
 void MappedPointer::release(void *object)
 {
-	if(object != nullptr)
+	if(object != UCOMMON_NULLPTR)
 		lock->release();
 }
 
--- corelib/thread.cpp
+++ corelib/thread.cpp
@@ -26,6 +26,7 @@
 #include <string.h>
 #include <stdarg.h>
 #include <limits.h>
+#include <sys/sysctl.h>
 
 #if _POSIX_PRIORITY_SCHEDULING > 0
 #include <sched.h>
@@ -34,6 +35,10 @@
 
 #undef  _POSIX_SPIN_LOCKS
 
+#ifndef UCOMMON_NULLPTR
+# define UCOMMON_NULLPTR NULL
+#endif
+
 namespace ucommon {
 
 #if _POSIX_TIMERS > 0 && defined(POSIX_TIMERS)
@@ -211,7 +216,7 @@
 
 void *Thread::Local::allocate()
 {
-    return nullptr;
+    return UCOMMON_NULLPTR;
 }
 
 void Thread::release(void)
@@ -1311,13 +1316,14 @@
     free(buffer);
     return line_size;
 #elif defined(__APPLE__)
-    size_t line_size = 0;
-    size_t sizeof_line_size = sizeof(line_size);
-    sysctlbyname("hw.cachelinesize", &line_size, &sizeof_line_size, 0, 0);
-    return line_size;
+    size_t lsize = 0;
+    size_t sizeof_line_size = sizeof(lsize);
+    sysctlbyname("hw.cachelinesize", &lsize, &sizeof_line_size, 0, 0);
+    return lsize;
 #elif defined(_SC_LEVEL1_DCACHE_LINESIZE)
+    const size_t neg_one = (size_t) -1;
     line_size = sysconf(_SC_LEVEL1_DCACHE_LINESIZE);
-    if(!line_size)
+    if(line_size == neg_one || line_size == 0)
         line_size = 64;
     return line_size;
 #elif defined(linux)
--- corelib/typeref.cpp
+++ corelib/typeref.cpp
@@ -36,7 +36,7 @@
 {
     TypeRelease *rel = autorelease;
     if(rel) {
-        autorelease = nullptr;
+        autorelease = UCOMMON_NULLPTR;
         rel->dealloc(this);
         return;
     }
@@ -225,7 +225,7 @@
 {
     value *v1 = polystatic_cast<value *>(ref);
     const char *str1 = "";
-    TypeRelease *ar = nullptr;
+    TypeRelease *ar = UCOMMON_NULLPTR;
 
     if(v1) {
         str1 = &v1->mem[0];
@@ -401,7 +401,7 @@
 TypeRef()
 {
     caddr_t p = ar->allocate(sizeof(value) + size);
-    TypeRef::set(new(mem(p)) value(p, size, nullptr, ar));
+    TypeRef::set(new(mem(p)) value(p, size, UCOMMON_NULLPTR, ar));
 }
 
 typeref<const uint8_t *>::typeref(bool mode, size_t bits, TypeRelease *ar) :
@@ -412,7 +412,7 @@
         ++size;
 
     caddr_t p = ar->allocate(sizeof(value) + size);
-    TypeRef::set(new(mem(p)) value(p, size, nullptr, ar));
+    TypeRef::set(new(mem(p)) value(p, size, UCOMMON_NULLPTR, ar));
     set(mode, 0, bits);
 }
 
@@ -449,7 +449,7 @@
         return 0;
 
     caddr_t p = ar->allocate(sizeof(value) + size);
-    TypeRef::set(new(mem(p)) value(p, size, nullptr, ar));
+    TypeRef::set(new(mem(p)) value(p, size, UCOMMON_NULLPTR, ar));
     String::hex2bin(str, data(), size, ws);
     return size;
 }
@@ -462,7 +462,7 @@
         return 0;
 
     caddr_t p = ar->allocate(sizeof(value) + size);
-    TypeRef::set(new(mem(p)) value(p, size, nullptr, ar));
+    TypeRef::set(new(mem(p)) value(p, size, UCOMMON_NULLPTR, ar));
     String::b64decode(data(), str, size, ws);
     return size;
 }
@@ -492,7 +492,7 @@
 typeref<const uint8_t *>::value *typeref<const uint8_t *>::create(size_t size, TypeRelease *ar)
 {
     caddr_t p = ar->allocate(sizeof(value) + size);
-    return new(mem(p)) value(p, size, nullptr, ar);
+    return new(mem(p)) value(p, size, UCOMMON_NULLPTR, ar);
 }
 
 void typeref<const uint8_t *>::destroy(typeref<const uint8_t *>::value *bytes)
@@ -561,7 +561,7 @@
     uint8_t *out;
     size_t s1 = 0, s2 = 0, max;
     typeref<const uint8_t*> result;
-    TypeRelease *ar = nullptr;
+    TypeRelease *ar = UCOMMON_NULLPTR;
 
     if(v1) {
         s1 = v1->max();
@@ -658,7 +658,7 @@
 
 void TypeRelease::release(TypeRef::Counted *obj)
 {
-    obj->autorelease = nullptr;
+    obj->autorelease = UCOMMON_NULLPTR;
     obj->dealloc();
 }
 
@@ -680,10 +680,10 @@
     TypeRef::Counted *obj = *root;
     if(obj) {
         *root = obj->linkrelease;
-        obj->autorelease = nullptr;
+        obj->autorelease = UCOMMON_NULLPTR;
     }
     else
-        *root = nullptr;
+        *root = UCOMMON_NULLPTR;
     return obj;
 }
 
@@ -714,7 +714,7 @@
 
 public:
     TypeReleaseLater() { 
-        list = nullptr; 
+        list = UCOMMON_NULLPTR; 
     }
 
     unsigned purge(void) __FINAL;
@@ -734,10 +734,10 @@
     TypeRef::Counted *pool;
     lock.acquire();
     pool = list;
-    list = nullptr;
+    list = UCOMMON_NULLPTR;
     lock.release();
 
-    while((obj = delist(&pool)) != nullptr) {
+    while((obj = delist(&pool)) != UCOMMON_NULLPTR) {
         TypeRelease::release(obj);
         ++count;
     }
--- inc/ucommon/arrayref.h
+++ inc/ucommon/arrayref.h
@@ -151,7 +151,7 @@
 	}
 
 	inline void release(void) {
-		TypeRef::set(nullptr);
+		TypeRef::set(UCOMMON_NULLPTR);
 	}
 
 	inline typeref<T> pull() {
@@ -219,7 +219,7 @@
 	}
 
 	inline void release(void) {
-		TypeRef::set(nullptr);
+		TypeRef::set(UCOMMON_NULLPTR);
 	}
 
 	inline typeref<T> pull() {
@@ -325,7 +325,7 @@
 	}
 
 	inline void release(void) {
-		TypeRef::set(nullptr);
+		TypeRef::set(UCOMMON_NULLPTR);
 	}
 };
 
--- inc/ucommon/generics.h
+++ inc/ucommon/generics.h
@@ -33,9 +33,11 @@
 #include <cstring>
 #include <stdexcept>
 
+// Do not declare an exception specification. It is an anti-pattern.
+// Also see https://stackoverflow.com/q/1055387.
 #ifndef UCOMMON_SYSRUNTIME
 #define THROW(x)    throw x
-#define THROWS(x)   throw(x)
+#define THROWS(x)
 #define THROWS_ANY  throw()
 #else
 #define THROW(x)    ::abort()
@@ -301,7 +303,7 @@
  */
 template<typename T>
 inline bool isnull(T& object) {
-    return (bool)(object.operator*() == nullptr);
+    return (bool)(object.operator*() == UCOMMON_NULLPTR);
 }
 
 /**
@@ -312,7 +314,7 @@
  */
 template<typename T>
 inline bool isnullp(T *object) {
-    return (bool)(object->operator*() == nullptr);
+    return (bool)(object->operator*() == UCOMMON_NULLPTR);
 }
 
 /**
--- inc/ucommon/platform.h
+++ inc/ucommon/platform.h
@@ -40,6 +40,27 @@
 #define _UCOMMON_PLATFORM_H_
 #define UCOMMON_ABI 7
 
+// https://clang.llvm.org/docs/LanguageExtensions.html
+#ifndef __has_feature
+# define __has_feature(x) 0
+#endif
+
+// Clang depends on __has_feature
+#if (_MSC_VER >= 1600) || __has_feature(cxx_nullptr) || \
+    ((__GNUC__ >= 5) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 6)) || \
+    (__INTEL_COMPILER >= 1000) || (__SUNPRO_CC >= 0x5130) || \
+    defined(__IBMCPP_NULLPTR)
+# undef  HAVE_NULLPTR
+# define HAVE_NULLPTR 1
+#endif
+
+// TODO: add configure.ac test
+#ifdef HAVE_NULLPTR
+# define UCOMMON_NULLPTR nullptr
+#else
+# define UCOMMON_NULLPTR NULL
+#endif
+
 #ifndef UCOMMON_SYSRUNTIME
 #ifndef NEW_STDCPP
 #define NEW_STDCPP
@@ -90,7 +111,7 @@
 #endif
 #endif
 
-#if !defined(__GNUC__) && !defined(__has_feature) && !defined(_MSC_VER)
+#if !defined(__GNUC__) && !defined(_MSC_VER)
 #define UCOMMON_RTTI    1
 #endif
 
@@ -102,11 +123,9 @@
 #define UCOMMON_RTTI    1
 #endif
 
-#if defined(__has_feature)
 #if __has_feature(cxx_rtti)
 #define UCOMMON_RTTI    1
 #endif
-#endif
 
 #ifdef  UCOMMON_RTTI
 #define __PROTOCOL   virtual
@@ -171,30 +190,6 @@
                                 __DELETE_COPY(x)
 #endif
 
-#if __cplusplus <= 199711L && !defined(_MSC_VER)
-#if defined(__GNUC_MINOR__) && !defined(__clang__)
-#define nullptr __null
-#elif !defined(__clang__) || (defined(__clang__) && defined(__linux__))
-const class nullptr_t 
-{
-public:
-    template<class T>
-    inline operator T*() const {
-        return 0; 
-    }
-
-    template<class C, class T>
-    inline operator T C::*() const {
-        return 0; 
-    }
-
-private:
-    void operator&() const;
-
-} nullptr = {};
-#endif
-#endif
-
 #ifndef __MALLOC
 #define __PRINTF(x, y)
 #define __SCANF(x, y)
@@ -392,13 +387,13 @@
     {};
 
 inline void pthread_mutex_lock(pthread_mutex_t *mutex)
-    {pth_mutex_acquire(mutex, 0, nullptr);};
+    {pth_mutex_acquire(mutex, 0, UCOMMON_NULLPTR);};
 
 inline void pthread_mutex_unlock(pthread_mutex_t *mutex)
     {pth_mutex_release(mutex);};
 
 inline void pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex)
-    {pth_cond_await(cond, mutex, nullptr);};
+    {pth_cond_await(cond, mutex, UCOMMON_NULLPTR);};
 
 inline void pthread_cond_signal(pthread_cond_t *cond)
     {pth_cond_notify(cond, FALSE);};
@@ -549,7 +544,7 @@
  */
 template<class T>
 inline T *init(T *memory)
-    {return ((memory) ? new(((void *)memory)) T : nullptr);}
+    {return ((memory) ? new(((void *)memory)) T : UCOMMON_NULLPTR);}
 
 typedef long Integer;
 typedef unsigned long Unsigned;
@@ -567,8 +562,8 @@
 inline T polypointer_cast(S *s)
 {
 #if defined(DEBUG) && defined(UCOMMON_RTTI)
-    if(s == nullptr)
-        return nullptr;
+    if(s == UCOMMON_NULLPTR)
+        return UCOMMON_NULLPTR;
     T ptr = dynamic_cast<T>(s);
     __THROW_DEREF(ptr);
     return ptr;
--- inc/ucommon/secure.h
+++ inc/ucommon/secure.h
@@ -971,7 +971,7 @@
 
     /**
      * Get peer (x509) certificate for current stream if present.
-     * @return certificate of peer or nullptr if none.
+     * @return certificate of peer or UCOMMON_NULLPTR if none.
      */
     inline secure::cert_t certificate(void) const {
         return cert;
--- inc/ucommon/shared.h
+++ inc/ucommon/shared.h
@@ -236,7 +236,7 @@
 			ip.next();
 		}
 		lock->release();
-		return nullptr;
+		return UCOMMON_NULLPTR;
 	}
 
 	void set(const K* key, V* ptr) {
--- inc/ucommon/socket.h
+++ inc/ucommon/socket.h
@@ -603,15 +603,15 @@
          * @return true if we have an address list.
          */
         inline operator bool() const {
-            return list != nullptr;
+            return list != UCOMMON_NULLPTR;
         }
 
         inline bool is_valid() const {
-            return list != nullptr;
+            return list != UCOMMON_NULLPTR;
         }
 
         inline bool isValid() const {
-            return list != nullptr;
+            return list != UCOMMON_NULLPTR;
         }
 
         /**
@@ -619,7 +619,7 @@
          * @return true if we have no address list.
          */
         inline bool operator!() const {
-            return list == nullptr;
+            return list == UCOMMON_NULLPTR;
         }
 
         /**
@@ -1959,7 +1959,7 @@
     }
 
     inline linked_pointer() {
-        ptr = nullptr;
+        ptr = UCOMMON_NULLPTR;
     }
 
     inline linked_pointer(Socket::address& list) {
@@ -2012,7 +2012,7 @@
      * @return true if we have an address list.
      */
     inline operator bool() const {
-        return ptr != nullptr;
+        return ptr != UCOMMON_NULLPTR;
     }
 
     /**
@@ -2063,7 +2063,7 @@
      * @return true if we have no address list.
      */
     inline bool operator!() const {
-        return ptr == nullptr;
+        return ptr == UCOMMON_NULLPTR;
     }
 
     inline void next(void) {
--- inc/ucommon/string.h
+++ inc/ucommon/string.h
@@ -1774,11 +1774,11 @@
     }
 
     inline operator bool() const {
-        return data != nullptr;
+        return data != UCOMMON_NULLPTR;
     }
 
     inline bool operator!() const {
-        return data == nullptr;
+        return data == UCOMMON_NULLPTR;
     }
 
     inline operator char*() const {
--- inc/ucommon/temporary.h
+++ inc/ucommon/temporary.h
@@ -53,9 +53,11 @@
 #include <cstring>
 #include <stdexcept>
 
+// Do not declare an exception specification. It is an anti-pattern.
+// Also see https://stackoverflow.com/q/1055387.
 #ifndef UCOMMON_SYSRUNTIME
 #define THROW(x)    throw x
-#define THROWS(x)   throw(x)
+#define THROWS(x)
 #define THROWS_ANY  throw()
 #else
 #define THROW(x)    ::abort()
--- inc/ucommon/thread.h
+++ inc/ucommon/thread.h
@@ -706,7 +706,7 @@
         void *get(void);
 
         inline void clear() {
-            set(nullptr);
+            set(UCOMMON_NULLPTR);
         }
     };
 
--- inc/ucommon/typeref.h
+++ inc/ucommon/typeref.h
@@ -267,7 +267,7 @@
 {
 public:
 	inline TypeRelease() {
-		delegate = nullptr;
+		delegate = UCOMMON_NULLPTR;
 	}
 
 	inline TypeRelease(TypeRelease *target) {
@@ -372,7 +372,7 @@
 	inline const T* operator()() const {
 		value *v = polystatic_cast<value*>(ref);
 		if(!v)
-			return nullptr;
+			return UCOMMON_NULLPTR;
 
 		return &(v->data);
 	}
@@ -566,7 +566,7 @@
 
 		uint8_t mem[1];
 
-		value(caddr_t addr, size_t size, const uint8_t *data = nullptr, TypeRelease *ar = &auto_release);
+		value(caddr_t addr, size_t size, const uint8_t *data = UCOMMON_NULLPTR, TypeRelease *ar = &auto_release);
 
 		void destroy(void);
 
--- test/datetime.cpp
+++ test/datetime.cpp
@@ -16,6 +16,10 @@
 // You should have received a copy of the GNU Lesser General Public License
 // along with GNU uCommon C++.  If not, see <http://www.gnu.org/licenses/>.
 
+#ifdef NDEBUG
+#undef NDEBUG
+#endif
+
 #ifndef DEBUG
 #define DEBUG
 #endif
--- test/digest.cpp
+++ test/digest.cpp
@@ -16,6 +16,10 @@
 // You should have received a copy of the GNU Lesser General Public License
 // along with GNU uCommon C++.  If not, see <http://www.gnu.org/licenses/>.
 
+#ifdef NDEBUG
+#undef NDEBUG
+#endif
+
 #ifndef DEBUG
 #define DEBUG
 #endif
--- test/keydata.cpp
+++ test/keydata.cpp
@@ -16,6 +16,10 @@
 // You should have received a copy of the GNU Lesser General Public License
 // along with GNU uCommon C++.  If not, see <http://www.gnu.org/licenses/>.
 
+#ifdef NDEBUG
+#undef NDEBUG
+#endif
+
 #ifndef DEBUG
 #define DEBUG
 #endif
--- test/linked.cpp
+++ test/linked.cpp
@@ -16,6 +16,10 @@
 // You should have received a copy of the GNU Lesser General Public License
 // along with GNU uCommon C++.  If not, see <http://www.gnu.org/licenses/>.
 
+#ifdef NDEBUG
+#undef NDEBUG
+#endif
+
 #ifndef DEBUG
 #define DEBUG
 #endif
--- test/memory.cpp
+++ test/memory.cpp
@@ -16,6 +16,10 @@
 // You should have received a copy of the GNU Lesser General Public License
 // along with GNU uCommon C++.  If not, see <http://www.gnu.org/licenses/>.
 
+#ifdef NDEBUG
+#undef NDEBUG
+#endif
+
 #ifndef DEBUG
 #define DEBUG
 #endif
@@ -188,7 +192,7 @@
     stringref_t sr = map(3);
     assert(eq(*sr, "hello"));
     sr = map(2);
-    assert(*sr == nullptr);
+    assert(*sr == UCOMMON_NULLPTR);
     typeref<int> ki(3);
     sr = "goodbye";
     map(ki, sr);
@@ -213,7 +217,7 @@
     map(9, "9");
     assert(map.used() == 2);
     sr = map(7);
-    assert(*sr == nullptr);
+    assert(*sr == UCOMMON_NULLPTR);
 
     listref<int> intlist;
     intlist << 3 << 5 << 7 << 9;
@@ -228,7 +232,7 @@
 
     mapped_pointer<char, maptest> pmap;
     maptest *out = pmap.get("bye");
-    assert(out == nullptr);
+    assert(out == UCOMMON_NULLPTR);
     pmap.release(out);
     pmap.set(mt[0].key, &mt[0]);
     pmap.set(mt[1].key, &mt[1]);
@@ -237,7 +241,7 @@
     pmap.release(out);
     pmap.remove("bye");
     out = pmap.get("bye");
-    assert(out == nullptr);
+    assert(out == UCOMMON_NULLPTR);
     pmap.release(out);
 
     int a = 1, b = 2;
--- test/shell.cpp
+++ test/shell.cpp
@@ -16,6 +16,10 @@
 // You should have received a copy of the GNU Lesser General Public License
 // along with GNU uCommon C++.  If not, see <http://www.gnu.org/licenses/>.
 
+#ifdef NDEBUG
+#undef NDEBUG
+#endif
+
 #ifndef DEBUG
 #define DEBUG
 #endif
--- test/socket.cpp
+++ test/socket.cpp
@@ -16,6 +16,10 @@
 // You should have received a copy of the GNU Lesser General Public License
 // along with GNU ucommon.  If not, see <http://www.gnu.org/licenses/>.
 
+#ifdef NDEBUG
+#undef NDEBUG
+#endif
+
 #ifndef DEBUG
 #define DEBUG
 #endif
--- test/stdcpp.cpp
+++ test/stdcpp.cpp
@@ -16,6 +16,10 @@
 // You should have received a copy of the GNU Lesser General Public License
 // along with GNU uCommon C++.  If not, see <http://www.gnu.org/licenses/>.
 
+#ifdef NDEBUG
+#undef NDEBUG
+#endif
+
 #ifndef DEBUG
 #define DEBUG
 #endif
--- test/stream.cpp
+++ test/stream.cpp
@@ -17,6 +17,10 @@
 // along with GNU uCommon C++.  If not, see <http://www.gnu.org/licenses/>.
 
 #ifndef UCOMMON_SYSRUNTIME
+#ifdef NDEBUG
+#undef NDEBUG
+#endif
+
 #ifndef DEBUG
 #define DEBUG
 #endif
--- test/string.cpp
+++ test/string.cpp
@@ -16,6 +16,10 @@
 // You should have received a copy of the GNU Lesser General Public License
 // along with GNU uCommon C++.  If not, see <http://www.gnu.org/licenses/>.
 
+#ifdef NDEBUG
+#undef NDEBUG
+#endif
+
 #ifndef DEBUG
 #define DEBUG
 #endif
--- test/thread.cpp
+++ test/thread.cpp
@@ -16,6 +16,10 @@
 // You should have received a copy of the GNU Lesser General Public License
 // along with GNU uCommon C++.  If not, see <http://www.gnu.org/licenses/>.
 
+#ifdef NDEBUG
+#undef NDEBUG
+#endif
+
 #ifndef DEBUG
 #define DEBUG
 #endif
@@ -48,8 +52,8 @@
     testThread() : JoinableThread() {};
 
     void run(void) {
-        assert(local.get() == nullptr);
-        assert(*local != nullptr);
+        assert(local.get() == UCOMMON_NULLPTR);
+        assert(*local != UCOMMON_NULLPTR);
 
         ++count;
         ::sleep(2);
@@ -62,9 +66,9 @@
     testThread *thr;
     void *mem;
 
-    assert(local.get() == nullptr);
+    assert(local.get() == UCOMMON_NULLPTR);
     mem = *local;
-    assert(mem != nullptr);
+    assert(mem != UCOMMON_NULLPTR);
     assert(mem == *local);
 
     time(&now);
--- test/unicode.cpp
+++ test/unicode.cpp
@@ -16,6 +16,10 @@
 // You should have received a copy of the GNU Lesser General Public License
 // along with GNU uCommon C++.  If not, see <http://www.gnu.org/licenses/>.
 
+#ifdef NDEBUG
+#undef NDEBUG
+#endif
+
 #ifndef DEBUG
 #define DEBUG
 #endif
